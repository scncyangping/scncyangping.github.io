---
layout:     post
title:      "Rust系列(七)内置结构"
subtitle:   ""
date:       2022-02-24 13:10:00
author:     "YaPi"
header-img: ""
tags:
    - Rust
---

#### 智能指针 Box
类似于C++中的智能指针。Box允许将一个值放在堆上而不是栈上，留在栈上的则是指向
堆数据的指针。当一个Box超出作用域时，它的析构函数被调用，内部对象被销毁，堆上的
内存被释放。

```text
fn main(){
    let b = Box::new(5);
    println!("b = {}",b);
}
```
Box没有运行上的性能损失，即便如此也需要在恰当时候使用：

- 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型时

```text
// 这种类型在编译的时候无法获取大小
enum List{
    //Cons(i32,List),
    // 修改为List地址类型
    Cons(i32,Box<List>),
    Nil
}

fn main(){
    let list = List::Cons(0,Box::new(List::Cons(1,Box::new(List::Cons(2,Box::new(List::Nil))))));
}
```

- 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候

```text
fn main(){
    // a 数组元素很多个 0 都存储在栈上面
    let a = [0,1024 * 512];

    // 会发生拷贝，从栈上拷贝到堆上
    let a_box= Box::new(a);
}
```

- 当希望拥有一个值并只关心它的类型是否实现了特定trait而不是其具体类型的时候

```text
fn main()-> Result<(),Box<dyn std::error::Error>>{
    let f = std::fs::read("/tmp/t.txt");
    Ok(());
}
```

#### Rc 引用计数
你可以将Rc看作Box的高级版本：它是带引用计数的智能指针。只有当它的引用计数为0时，数据才会
被清理。

```text
// 需要先引入 Rc
use std::rc::Rc;
use List::Cons;

enum List{
    //Cons(i32,List),
    // 修改为List地址类型
    Cons(i32,Rc<List>),
    Nil
}

fn main(){
    // Rc 使一个值可以有多个所有者
    let four = Rc::new(Cons(4,Rc::new(List::Nil)));
    // 调用clone方法后，引用计数会加1, 不是说将原来的数据复制一份儿
    let zero = List::Cons(0,Rc::new(List::Cons(1,four.clone())));
    // 使用 Rc::clone(&four)一样的可以复制
    let two = List::Cons(2,Rc::new(List::Cons(3,Rc::clone(&four))));
    let three = List::Cons(2,Rc::new(List::Cons(4,Rc::clone(&four))));
}
```



