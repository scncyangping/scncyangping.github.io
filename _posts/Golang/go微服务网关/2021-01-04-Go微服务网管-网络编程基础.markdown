---
layout:     post
title:      "Go微服务网关(一)网络编程基础"
subtitle:   ""
date:       2021-01-04 12:01:00
author:     "YaPi"
header-img: ""
tags:
    - golang
---

#### 网络协议

![avatar](https://blog-1257627424.cos.ap-chengdu.myqcloud.com/golang/OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.jpg)

#### 经典协议与数据包

![avatar](https://blog-1257627424.cos.ap-chengdu.myqcloud.com/golang/%E7%BB%8F%E5%85%B8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8C%85.jpg)

以太网首部，包含主机mac地址等信息

#### TCP的三次握手和四次挥手

![avatar](https://blog-1257627424.cos.ap-chengdu.myqcloud.com/golang/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg)
为什么需要3次握手？
主要目的是保证连接是双工和可靠的，可靠更多是通过重传机制来保证的。

双工是指发送和接受是可以同时执行的。

![avatar](https://blog-1257627424.cos.ap-chengdu.myqcloud.com/golang/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg)
为什么需要四次挥手？
因为连接是全双工的，双方必须都收到对方的FIN包及确认才可关闭。

![avatar](https://blog-1257627424.cos.ap-chengdu.myqcloud.com/golang/%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90.jpg)

为什么最大等待时间是2MSL?

MSL : Maximum Segment Lifetime, 30s~1分钟。最大的段的生命周期。

- 保证TCP协议的全双工连接能够可靠关闭。

若主动关闭放发送最后一个ack包不等到2MSL的话：若这个ack包丢失了，主动发送放可以通过失败重传机制，再次
发送FIN包给主动关闭方，若没有2MSL，可能就收不到这个包，同时主动关闭方关闭了通道，那么被动关闭方就会一直
处于LAST-ACK状态，资源得不到释放。

- 保证这次连接的重复数据段从网络中消失

若不等待的话，当关闭了这次会话过后，又建立了连接，恰好是同样的服务器，同样的端口。若不等待2MSL，在前一次最后一次
的请求接受失败，就会重传，那么新建立的连接就会收到不正确的消息。

为啥会出现大量的close_wait?

- 首先，close_wait一般出现在被动关闭方
- 并发请求太多导致
- 被动关闭方未及时释放端口资源导致


TCP为啥需要流量控制？UDP不需要？
UDP是不可靠的连接，发送了就不管了，不需要控制

TCP需要流量控制的原因：

- 由于通讯双方，网速不同。通讯方任一发送过快都会导致对方消息处理不过来，所以就需要把数据
放到缓冲区中
- 如果缓冲区满了，发送方还在疯狂发送，那接收方只能把数据包丢弃。因此我们需要控制发送速率 
- 缓冲区剩余大小称之为接受窗口，用变量win表示，如果win=0，则发送方停止发送。


![avatar](https://blog-1257627424.cos.ap-chengdu.myqcloud.com/golang/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg)

TCP为啥需要用塞控制？

拥塞控制和流量控制是两个概念，拥塞控制是调整网络负载
产生的原因： 接收方网络资源繁忙，因未及时响应ACK导致发送方重传大量数据，这样将会导致网络
更加拥堵。
解决：拥塞控制动态调整win大小，不只是依赖缓冲区确定窗口大小，主要分为两个部分

![avatar](https://blog-1257627424.cos.ap-chengdu.myqcloud.com/golang/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.jpg)

- 慢开始
  > 刚刚建立的时候一点点的提速，试探网络的速度。
- 拥塞避免
