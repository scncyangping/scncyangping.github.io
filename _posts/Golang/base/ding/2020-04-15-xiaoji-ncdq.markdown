---
layout:     post
title:      "Go小记 - 指针运算和内存对其"
subtitle:   ""
date:       2020-04-16 02:40:00
author:     "YaPi"
header-img: ""
tags:
    - golang
---

### 为什么需要内存对齐

- 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常（32位平台上运行64位平台上编译的程序要求必须8字节对齐，否则发生panic）
- 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问


我们知道计算机中内存是以字节为单位划分的，CPU通过地址总线来访问内存，CPU一个时钟周期内能处理多少字节的数据，
就命令地址总线读取几个字节的数据。举个例子：32位的CPU，一次能处理32bit的数据，也就是4字节的数据，那么CPU就
命令地址总线一次性读取4字节的数据，即每次的步长都为4字节，只对地址是4的整倍数的地址进行寻址，比如：0,4,8,100等进行寻址。
对于程序来说，一个变量的地址最好刚在一个寻址步长内，这样一次寻址就可以读取到该变量的值，如果变量跨步长存储，就需要寻址两次
甚至多次然后再进行拼接才能获取到变量的值，效率明显就低了，所以编译器会进行内存对齐，以保证寻址效率。

32位CPU为例，寻址步长为4，程序中如果一个int变量的地址为8，那么一次寻址就可以拿到该变量的值，如果int变量的地址为10，
那么需要先寻址地址为8的地址拿到数据的一部分，再寻址12的地址拿到另一部分，然后再进行拼接

### 指针运算

```
type W struct {
   b int32
   c int64
}
var w *W = new(W)
//这时w的变量打印出来都是默认值0，0
fmt.Println(w.b,w.c)

//现在我们通过指针运算给b变量赋值为10
b := unsafe.Pointer(uintptr(unsafe.Pointer(w)) + unsafe.Offsetof(w.b))
*((*int)(b)) = 10
//此时结果就变成了10，0
fmt.Println(w.b,w.c)
```