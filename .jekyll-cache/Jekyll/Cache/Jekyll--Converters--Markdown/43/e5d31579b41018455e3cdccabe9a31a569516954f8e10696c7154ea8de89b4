I"ì&<h4 id="time">Time</h4>

<p>Time ä»£è¡¨ä¸€ä¸ªçº³ç§’ç²¾åº¦çš„æ—¶é—´ç‚¹ã€‚ç¨‹åºä¸­åº”ä½¿ç”¨Timeç±»å‹å€¼æ¥ä¿å­˜å’Œä¼ é€’æ—¶é—´,è€Œä¸æ˜¯æŒ‡é’ˆã€‚ å°±æ˜¯è¯´,è¡¨ç¤ºæ—¶é—´çš„å˜é‡å’Œå­—æ®µåº”ä¸ºtime.Timeç±»å‹,è€Œä¸æ˜¯*time.Timeç±»å‹ã€‚</p>

<p>ä¸€ä¸ªTimeç±»å‹çš„å€¼å¯ä»¥è¢«å¤šä¸ªgoç¨‹åŒæ—¶ä½¿ç”¨ã€‚æ—¶é—´ç‚¹å¯ä»¥ä½¿ç”¨Beforeã€Afterã€Equalæ–¹æ³•è¿›è¡Œæ¯”è¾ƒã€‚Subæ–¹æ³•è®©ä¸¤ä¸ªæ—¶é—´ç‚¹ç›¸å‡,ç”Ÿæˆä¸€ä¸ªDurationç±»å‹å€¼(ä»£è¡¨æ—¶é—´æ®µ)ã€‚Addæ–¹æ³•ç»™ä¸€ä¸ªæ—¶é—´ç‚¹åŠ ä¸Šä¸€ä¸ªæ—¶é—´æ®µ,ç”Ÿæˆä¸€ä¸ªæ–°çš„Timeç±»å‹æ—¶é—´ç‚¹ã€‚</p>

<p>æ¯â¼€ä¸ªæ—¶é—´éƒ½å…·æœ‰â¼€ä¸ªåœ°ç‚¹ä¿¡æ¯ï¼ˆåŠå¯¹åº”åœ°ç‚¹çš„æ—¶åŒºä¿¡æ¯ï¼‰ï¼Œå½“è®¡ç®—æ—¶é—´çš„è¡¨ç¤ºæ ¼å¼æ—¶ï¼Œå¦‚Formatã€Hourå’ŒYearç­‰â½…æ³•ï¼Œéƒ½ä¼šè€ƒè™‘è¯¥ä¿¡æ¯ã€‚Localã€UTCå’ŒInâ½…æ³•è¿”å›â¼€
ä¸ªæŒ‡å®šæ—¶åŒºï¼ˆä½†æŒ‡å‘åŒâ¼€æ—¶é—´ç‚¹ï¼‰çš„Timeã€‚ä¿®æ”¹åœ°ç‚¹/æ—¶åŒºä¿¡æ¯åªæ˜¯ä¼šæ”¹å˜å…¶è¡¨ç¤ºï¼›ä¸ä¼šä¿®æ”¹è¢«è¡¨ç¤ºçš„æ—¶é—´ç‚¹ï¼Œå› æ­¤ä¹Ÿä¸ä¼šå½±å“å…¶è®¡ç®—ã€‚é€šè¿‡ == â½è¾ƒ Time æ—¶ï¼ŒLocation ä¿¡æ¯ä¹Ÿä¼šå‚ä¸â½è¾ƒï¼Œå› æ­¤ Time ä¸åº”è¯¥ä½œä¸º map çš„key</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Time struct {
	// wall and ext encode the wall time seconds, wall time nanoseconds,
	// and optional monotonic clock reading in nanoseconds.
	//
	// From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),
	// a 33-bit seconds field, and a 30-bit wall time nanoseconds field.
	// The nanoseconds field is in the range [0, 999999999].
	// If the hasMonotonic bit is 0, then the 33-bit field must be zero
	// and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.
	// If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit
	// unsigned wall seconds since Jan 1 year 1885, and ext holds a
	// signed 64-bit monotonic clock reading, nanoseconds since process start.
	wall uint64
	ext  int64

	// loc specifies the Location that should be used to
	// determine the minute, hour, month, day, and year
	// that correspond to this Time.
	// The nil location means UTC.
	// All UTC times are represented with loc==nil, never loc==&amp;utcLoc.
	loc *Location
}
</code></pre></div></div>

<h5 id="ä¸-unix-æ—¶é—´æˆ³çš„è½¬æ¢">ä¸ Unix æ—¶é—´æˆ³çš„è½¬æ¢</h5>

<ul>
  <li>time.Unix(sec, nsec int64) é€šè¿‡ Unix æ—¶é—´æˆ³â½£æˆ time.Time å®ä¾‹</li>
  <li>time.Time.Unix() å¾—åˆ° Unix æ—¶é—´æˆ³</li>
  <li>time.Time.UnixNano() å¾—åˆ° Unix æ—¶é—´æˆ³çš„çº³ç§’è¡¨ç¤º</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ä¼ å…¥ç§’æ•° + çº³ç§’æ•° --&gt; è¿”å›äºŒè€…ä¹‹å’Œä»£è¡¨çš„æ—¶é—´
fmt.Println(time.Unix(1565858822, 555))
è¾“å‡º: 2019-08-15 16:47:02.000000555 +0800 CST


fmt.Println(time.Now().Unix())
è¾“å‡º: 1565859300


fmt.Println(time.Now().UnixNano())
è¾“å‡º: 1565859300949946000
</code></pre></div></div>

<h5 id="æ ¼å¼åŒ–å’Œè§£æ">æ ¼å¼åŒ–å’Œè§£æ</h5>

<ul>
  <li>time.Parse å’Œ time.ParseInLocation</li>
  <li>time.Time.Format</li>
</ul>

<p>time.Now()è·å–çš„æ—¶é—´æ—¶åŒºæ˜¯Local,è€Œtime.Parseè§£æå‡ºæ¥çš„æ—¶åŒºæ˜¯UTC,æ‰€ä»¥ä¸€èˆ¬ä¸ç”¨time.Parse,è€Œæ˜¯ç”¨time.ParseInLocation</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Local
fmt.Println(time.Now().Location().String())

t, _ := time.Parse("2006-01-02 15:04:05", "2019-08-15 14:14:00")
// UTC
fmt.Println(t.Location().String())

// -4.979531593611111 æ—¶åŒºä¸å¯¹,æ‰€ä»¥é”™äº†
fmt.Println(time.Now().Sub(t).Hours())

t2, _ := time.ParseInLocation("2006-01-02 15:04:05", "2019-08-15 14:14:00", time.Local)
// Local
fmt.Println(t2.Location().String())

// 3.020468415
fmt.Println(time.Now().Sub(t2).Hours())

//
fmt.Println(time.Now().Format("2006-01-02 15:04:05"))

</code></pre></div></div>

<h5 id="round-å’Œ-truncate-æ³•">Round å’Œ Truncate â½…æ³•</h5>

<p>â½å¦‚ï¼Œæœ‰è¿™ä¹ˆä¸ªéœ€æ±‚ï¼šè·å–å½“å‰æ—¶é—´æ•´ç‚¹çš„Timeå®ä¾‹ã€‚ä¾‹å¦‚ï¼Œå½“å‰æ—¶é—´æ˜¯15:54:23ï¼Œéœ€è¦çš„æ˜¯15:00:00ã€‚æˆ‘ä»¬å¯ä»¥è¿™ä¹ˆåš:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t, _ := time.ParseInLocation("2006-01-02 15:04:05", time.Now().Format("2006-01-02 15:0
0:00"), time.Local)

fmt.Println(t)
</code></pre></div></div>

<p>time åŒ…ç»™æˆ‘ä»¬æä¾›äº†ä¸“â»”çš„â½…æ³•ï¼ŒåŠŸèƒ½æ›´å¼ºâ¼¤ï¼Œæ€§èƒ½ä¹Ÿæ›´å¥½ï¼Œè¿™å°±æ˜¯Roundå’ŒTrunateå®ƒä»¬åŒºåˆ«ï¼Œâ¼€ä¸ªæ˜¯å–æœ€æ¥è¿‘çš„ï¼Œâ¼€ä¸ªæ˜¯å‘ä¸‹å–æ•´</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t, _ := time.ParseInLocation("2006-01-02 15:04:05", "2016-06-13 15:34:39", time.Local)
// æ•´ç‚¹ï¼ˆå‘ä¸‹å–æ•´ï¼‰
fmt.Println(t.Truncate(1 * time.Hour))

// æ•´ç‚¹ï¼ˆæœ€æ¥è¿‘ï¼‰
fmt.Println(t.Round(1 * time.Hour))

// æ•´åˆ†ï¼ˆå‘ä¸‹å–æ•´ï¼‰
fmt.Println(t.Truncate(1 * time.Minute))

// æ•´åˆ†ï¼ˆæœ€æ¥è¿‘ï¼‰
fmt.Println(t.Round(1 * time.Minute))
t2, _ := time.ParseInLocation("2006-01-02 15:04:05", t.Format("2006-01-02 15:00:00"),
time.Local)
fmt.Println(t2)
</code></pre></div></div>

<h5 id="å®šæ—¶å™¨">å®šæ—¶å™¨</h5>

<ul>
  <li>Timer (åˆ°è¾¾æŒ‡å®šæ—¶é—´è§¦å‘ä¸”åªè§¦å‘â¼€æ¬¡)</li>
  <li>Ticker (é—´éš”ç‰¹å®šæ—¶é—´è§¦å‘)</li>
</ul>

<h6 id="timer">Timer</h6>

<p>Timer ç±»å‹ä»£è¡¨å•æ¬¡æ—¶é—´äº‹ä»¶ã€‚å½“ Timer åˆ°æœŸæ—¶ï¼Œå½“æ—¶çš„æ—¶é—´ä¼šè¢«å‘é€ç»™ C (channel)ï¼Œé™¤â¾®Timer æ˜¯è¢« AfterFunc å‡½æ•°åˆ›å»ºçš„</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Timer struct {
    C &lt;-chan Time // The channel on which the time is delivered.
    r runtimeTimer
}
</code></pre></div></div>

<p>runtimeTimer</p>

<p>å®ƒå®šä¹‰åœ¨sleep.goâ½‚ä»¶ä¸­ï¼Œå¿…é¡»å’ŒruntimeåŒ…ä¸­time.goâ½‚ä»¶ä¸­çš„timerå¿…é¡»ä¿æŒâ¼€è‡´</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type timer struct {
    i int // heap index
    // Timer wakes up at when, and then at when+period, ... (period &gt; 0 only)
    // each time calling f(now, arg) in the timer goroutine, so f must be
    // a well-behaved function and not block.
    when int64
    period int64
    f func(interface{}, uintptr)
    arg interface{}
    seq uintptr
}
</code></pre></div></div>

<p>åˆ›å»º</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func NewTimer(d Duration) *Timer {
    c := make(chan Time, 1)
    t := &amp;Timer{
    C: c,
    r: runtimeTimer{
    when: when(d),
    f: sendTime,
    arg: c,
    },
    }
    startTimer(&amp;t.r)
    return t
}

</code></pre></div></div>

<p>åœ¨ when è¡¨ç¤ºçš„æ—¶é—´åˆ°æ—¶ï¼Œä¼šå¾€ Timer.Cä¸­å‘é€å½“å‰æ—¶é—´ã€‚whenè¡¨ç¤ºçš„æ—¶é—´æ˜¯çº³ç§’
æ—¶é—´,æ­£å¸¸é€šè¿‡ runtimeNano() + int64(d) èµ‹å€¼ã€‚è·Ÿä¸Šâ¼€èŠ‚ä¸­è®²åˆ°çš„ now() ç±»
ä¼¼,runtimeNano() ä¹Ÿåœ¨ runtime ä¸­å®ç°ï¼ˆ runtimeÂ·nanotime ï¼‰</p>

<ul>
  <li>è°ƒâ½¤ç³»ç»Ÿè°ƒâ½¤ clock_gettimeè·å–æ—¶é’Ÿå€¼ï¼ˆè¿™æ˜¯POSIXæ—¶é’Ÿï¼‰ã€‚å…¶ä¸­clockid_tæ—¶é’Ÿç±»å‹æ˜¯ CLOCK_MONOTONICï¼Œä¹Ÿå°±æ˜¯ä¸å¯è®¾å®šçš„æ’å®šæ€æ—¶é’Ÿã€‚å…·ä½“çš„æ˜¯ä»€ä¹ˆæ—¶é—´ï¼ŒSUSv3 è§„å®šå§‹äºæœªäºˆè§„èŒƒçš„è¿‡å»æŸâ¼€ç‚¹ï¼ŒLinux ä¸Šï¼Œå§‹äºç³»ç»Ÿå¯åŠ¨ã€‚</li>
  <li>å¦‚æœ clock_gettime ä¸å­˜åœ¨ï¼Œåˆ™ä½¿â½¤ç²¾åº¦å·®äº›çš„ç³»ç»Ÿè°ƒâ½¤ gettimeofday</li>
</ul>

<p>å®šæ—¶å™¨çš„å…·ä½“å®ç°é€»è¾‘ï¼Œéƒ½åœ¨runtimeä¸­çš„time.goä¸­ï¼Œå®ƒçš„å®ç°ï¼Œæ²¡æœ‰é‡‡â½¤ç»å…¸Unixé—´éš”å®šæ—¶å™¨setitimerç³»ç»Ÿè°ƒâ½¤ï¼Œä¹Ÿæ²¡æœ‰é‡‡â½¤POSIXé—´éš”å¼å®šæ—¶å™¨ï¼ˆç›¸å…³ç³»ç»Ÿè°ƒâ½¤ï¼štimer_createã€timer_settimeå’Œtimer_deleteï¼‰ï¼Œâ½½æ˜¯é€šè¿‡å››å‰æ ‘å †(heep)å®ç°çš„ï¼ˆruntimeTimerç»“æ„ä¸­çš„iå­—æ®µï¼Œè¡¨ç¤ºåœ¨å †ä¸­çš„ç´¢å¼•ï¼‰ã€‚é€šè¿‡æ„å»ºâ¼€ä¸ªæœ€â¼©å †ï¼Œä¿è¯æœ€å¿«æ‹¿åˆ°åˆ°æœŸäº†çš„å®šæ—¶å™¨æ‰§â¾ã€‚å®šæ—¶å™¨çš„æ‰§â¾ï¼Œåœ¨ä¸“â»”çš„goroutineä¸­è¿›â¾çš„ï¼šgotimerproc()ã€‚æœ‰å…´è¶£çš„åŒå­¦ï¼Œå¯ä»¥é˜…è¯»runtime/time.goçš„æºç </p>

<h6 id="timer-ç›¸å…³å‡½æ•°æˆ–æ³•çš„ä½¿">Timer ç›¸å…³å‡½æ•°æˆ–â½…æ³•çš„ä½¿â½¤</h6>

<p>é€šè¿‡ time.After æ¨¡æ‹Ÿè¶…æ—¶</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c := make(chan int)
go func() {
    // time.Sleep(1 * time.Second)
    time.Sleep(3 * time.Second)
    &lt;-c
}()

select {
case c &lt;- 1:
    fmt.Println("channel...")
case &lt;-time.After(2 * time.Second):
    close(c)
    fmt.Println("timeout...")
}

è¾“å‡º timeout...
</code></pre></div></div>

<h6 id="timestop-åœå®šæ—¶å™¨-æˆ–-timereset-é‡ç½®å®šæ—¶å™¨">time.Stop åœâ½Œå®šæ—¶å™¨ æˆ– time.Reset é‡ç½®å®šæ—¶å™¨</h6>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>start := time.Now()
timer := time.AfterFunc(2*time.Second, func() {
    fmt.Println("after func callback, elaspe:", time.Now().Sub(start))
})
time.Sleep(1 * time.Second)
// time.Sleep(3*time.Second)
// Reset åœ¨ Timer è¿˜æœªè§¦å‘æ—¶è¿”å› trueï¼›è§¦å‘äº†æˆ–Stopäº†ï¼Œè¿”å›false
if timer.Reset(3 * time.Second) {
    fmt.Println("timer has not trigger!")
} else {
    fmt.Println("timer had expired or stop!")
}
time.Sleep(10 * time.Second)
// output:
// timer has not trigger!
// after func callback, elaspe: 4.00026461s

</code></pre></div></div>

<h6 id="sleepå†…éƒ¨å®ç°">sleepå†…éƒ¨å®ç°</h6>

<p>æŸ¥çœ‹runtime/time.goâ½‚ä»¶ä¸­çš„timeSleepå¯çŸ¥ï¼ŒSleepçš„æ˜¯é€šè¿‡Timerå®ç°çš„ï¼ŒæŠŠå½“å‰goroutineä½œä¸ºargå‚æ•°ï¼ˆgetg())ã€‚</p>

<p>å¦‚æœå®šæ—¶å™¨è¿˜æœªè§¦å‘ï¼ŒStopä¼šå°†å…¶ç§»é™¤ï¼Œå¹¶è¿”å›trueï¼›å¦åˆ™è¿”å›falseï¼›åç»­å†å¯¹è¯¥Timerè°ƒâ½¤Stopï¼Œç›´æ¥è¿”å›falseã€‚Resetä¼šå…ˆè°ƒâ½¤stopTimerå†è°ƒâ½¤startTimerï¼Œç±»ä¼¼äºåºŸå¼ƒä¹‹å‰çš„å®šæ—¶å™¨ï¼Œé‡æ–°å¯åŠ¨â¼€ä¸ªå®šæ—¶å™¨ã€‚è¿”å›å€¼å’ŒStopâ¼€æ ·ã€‚</p>

<h5 id="ticker-ç›¸å…³å‡½æ•°æˆ–æ³•çš„ä½¿">Ticker ç›¸å…³å‡½æ•°æˆ–â½…æ³•çš„ä½¿â½¤</h5>

<p>Tickerå’ŒTimerç±»ä¼¼ï¼ŒåŒºåˆ«æ˜¯ï¼šTickerä¸­çš„runtimeTimerå­—æ®µçš„periodå­—æ®µä¼šèµ‹å€¼ä¸ºNewTicker(dDuration)ä¸­çš„dï¼Œè¡¨ç¤ºæ¯é—´éš”dçº³ç§’ï¼Œå®šæ—¶å™¨å°±ä¼šè§¦å‘â¼€æ¬¡ã€‚é™¤â¾®ç¨‹åºç»ˆâ½Œå‰å®šæ—¶å™¨â¼€ç›´éœ€è¦è§¦å‘ï¼Œå¦åˆ™ï¼Œä¸éœ€è¦æ—¶åº”è¯¥è°ƒâ½¤Ticker.Stopæ¥é‡Šæ”¾ç›¸å…³èµ„æºã€‚å¦‚æœç¨‹åºç»ˆâ½Œå‰éœ€è¦å®šæ—¶å™¨â¼€ç›´è§¦å‘ï¼Œå¯ä»¥ä½¿â½¤æ›´ç®€å•â½…ä¾¿çš„time.Tickå‡½æ•°ï¼Œå› ä¸ºTickerå®ä¾‹éšè—èµ·æ¥äº†ï¼Œå› æ­¤ï¼Œè¯¥å‡½æ•°å¯åŠ¨çš„å®šæ—¶å™¨â½†æ³•åœâ½Œã€‚</p>
:ET